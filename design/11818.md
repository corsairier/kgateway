# EP-11818: kgateway + agentgateway tracing integration

* Issue: [#11818](https://github.com/kgateway-dev/kgateway/issues/11818)

## Background

Currently, agentgateway supports OpenTelemetry tracing, but it is configured statically via a ConfigMap at startup. This configuration is applied globally, meaning tracing is either enabled for all traffic with a single configuration or disabled entirely. This approach lacks the flexibility to apply different tracing strategies to different listeners or to enable/disable tracing at runtime without a pod restart.

The kgateway control plane already supports dynamic policy attachment for other features, and the HTTPListenerPolicy CRD provides a user-facing API for configuring listener-level behavior, including tracing for the Envoy data plane.

## Motivation

The goal of this proposal is to refactor the existing tracing implementation in agentgateway from a static, startup-time configuration to a dynamic, policy-driven model. This will allow operators to enable, disable, and configure tracing behavior on a per-listener basis at runtime, using policies applied in Kubernetes.

## Goals

* Refactor the agentgateway data plane to support multiple, dynamically configured OpenTelemetry tracer instances.
* Introduce a mechanism in the kgateway control plane to translate a user-facing policy into an agentgateway-specific xDS resource for tracing.
* Enable per-listener tracing configurations, including service name, sampling, OTLP endpoint, and trace attributes.
* Ensure the solution is robust, performant, and aligns with the existing policy and xDS architecture of both kgateway and agentgateway.
* Provide a clear test plan for validating the dynamic configuration updates and trace data generation.

## Non-Goals

* Implementing tracing on a per-route or per-request basis. The initial scope is listener-level granularity.
* Adding support for tracing providers other than OpenTelemetry.

## Implementation Details

### Sample YAML API

```yaml
apiVersion: gateway.kgateway.dev/v1alpha1
kind: AgentGatewayObservabilityPolicy
metadata:
  name: tracing-policy
  namespace: default
spec:
  targetRefs:
  - group: gateway.networking.k8s.io
    kind: Gateway
    name: gw
  tracing:
    provider:
      openTelemetry:
        serviceName: "my:service"
        resourceDetectors:
        - environmentResourceDetector: {}
        grpcService:
          backendRef:
            name: otel-collector
            namespace: default
            port: 4317
    attributes:
      - name: "http.request.id"
        value: "request.headers['x-request-id']"
      - name: "http.host"
        value: "request.host"
```

### API and Configuration Options

We have two primary options for how this feature is exposed to users and represented internally.

#### Option 1: Use Existing HTTPListenerPolicy

This approach leverages the existing `gateway.kgateway.dev/v1alpha1/HTTPListenerPolicy` CRD.

* **Control Plane (`kgateway`)**: A new plugin, `HTTPListenerPolicyPlugin`, will be created in the `agentgatewaysyncer`. This plugin will watch for `HTTPListenerPolicy` resources. When it finds one with a `spec.tracing` block, it will translate it into an agentgateway xDS Policy resource.
* **Data Plane (`agentgateway`)**: The `resource.proto` will be updated to include a `Tracing` message within the `PolicySpec` oneof. agentgateway will consume this policy, attaching it to the specified listener.

**Pros:**
* Reuses a familiar, existing API.
* Maintains consistency for users who also manage Envoy through kgateway.
* Fits naturally into the existing policy translation framework.

**Cons:**
* Couples agentgateway's tracing features to an Envoy-centric API. Future agentgateway-specific tracing features might not fit cleanly.

#### Option 2: Create a New AgentGatewayObservabilityPolicy

This approach involves creating a new, dedicated CRD for agentgateway-specific observability features.

* **Control Plane (`kgateway`)**: A new CRD (`AgentGatewayObservabilityPolicy`) and a corresponding controller plugin would be created. This policy would have a tracing section tailored specifically for agentgateway.
* **Data Plane (`agentgateway`)**: The implementation would be identical to Option 1, consuming a `Tracing` policy via xDS.

**Pros:**
* Decouples agentgateway from Envoy's API model, allowing for a purpose-built API.
* Provides a single, clear place for all future agentgateway observability settings (metrics, logging, etc.).

**Cons:**
* Introduces a new CRD for users to learn and manage.
* More initial implementation overhead.


### Data Plane Implementation (agentgateway)

Regardless of the control plane API chosen, the implementation within agentgateway will follow this plan:

1. **Protobuf Definition (`resource.proto`)**:
   A `Tracing` message will be added to the `PolicySpec` oneof. This message will contain fields for the OpenTelemetry provider config, `spawn_upstream_span`, and a list of attributes, mirroring the structure of the `HTTPListenerPolicy`.

   ```protobuf
   message PolicySpec {
     oneof kind {
       // ... existing policies
       Tracing tracing = 14;
     }
   }

   message Tracing {
     OpenTelemetryProvider provider = 1;
     bool spawn_upstream_span = 2;
     repeated TracingAttribute attributes = 3;
   }
   // ... other necessary message definitions for provider, attributes, etc.
   ```

2. **Refactor `telemetry/trc.rs` to `TracerProviderCache`**:
   The existing static `Tracer` will be evolved into a dynamic factory and cache.
   * The struct will be renamed to `TracerProviderCache`.
   * It will hold a `Mutex<HashMap<TracingConfig, Arc<TracerProvider>>>` to store and reuse provider instances.
   * The core logic from the current `Tracer::new` will be moved into a new `get_or_create_provider(&self, config: &TracingConfig) -> Arc<TracerProvider>` method.
   * This method will build and return a `TracerProvider` based on the dynamic config argument, without installing it globally.

3. **Implement `TracingLayer` Middleware**:
   A new tower middleware will be created in `proxy/tracing_layer.rs`.
   * The `TracingLayer` will be initialized with an `Arc<TracerProvider>` and the `TracingConfig`.
   * Its `Service::call` implementation will use the provider to start and manage the lifecycle of a span for each request, adding attributes from the config.

4. **Proxy Integration (`proxy/httpproxy.rs`)**:
   * The `TracerProviderCache` will be initialized once and made available to the proxy's shared state.
   * The static, global tracer initialization will be removed from the application startup.
   * In the request handling logic, after a listener is selected, the code will query the policy store for a `TracingConfig` policy attached to either the listener or its parent gateway.
   * If a policy is found, it will use the `TracerProviderCache` to get the appropriate provider, create a `TracingLayer`, and apply it to the service stack for that request.

## Alternatives

*   **Use Existing `HTTPListenerPolicy`**: This was initially considered but ultimately not preferred during review. `HTTPListenerPolicy` is heavily coupled to Envoy's specific configuration (e.g., integer-based sampling, Envoy-specific gRPC fields). Reusing it would be confusing for users and limit `agentgateway`'s ability to have its own tailored features, such as CEL-based attributes.

## Open Questions

1. As we finalize the API for our new AgentGatewayObservabilityPolicy, which concepts should we consider borrowing or adapting, and what new, agentgateway-specific capabilities should we prioritize? Some has been suggested by John Howard [here](https://github.com/kgateway-dev/kgateway/pull/12478#discussion_r2399532482).

3. Should the initial `AgentGatewayObservabilityPolicy` CRD include tracing and metrics support too or are they going to be supported by `HTTPListenerPolicy`?